title: Usage optimization

h3. Usage optimisations for liquidsoap.

This page lists various optimizations that can be used for running liquidsoap under various 
conditions and hardware.

h4. Load optimization.

On machine with several cores, liquidsoap's load can be reduced by splitting
computations into several processes. This will ease the operating system to balance 
the load of the processes to the various cores.

For communicating between the instances, you can use the @{input,output}.jack@ operators,
but this does not communicate metadata and breaks (end of tracks). You can also
give a try to the experimental @{input,output}.marshal@ operators, but using them can be 
troublesome.

Also, using an external encoder helps reducing the load. However, it is not recommended for any 
format using the ogg format.

h4. Memory usage.

Liquidsoap uses caml's @float@ to represent raw audio data. While this is a great optimization for
CPU usage, this may consume a lot of memory, in particular when buffering a lot of data.

If you want to optimize memory usage in this kind of situations, the global setting @set("buffering.kind","raw")@ 
will force data buffering to be done in PCM S16LE format, which representation in memory is smaller.

However, in this case, data will be translated back and forth for each buffering, leading to some computational
cost.

Other possible values for this operator are:

* @"default"@: standard representation.
* @"disk"@: will store temporary data in several big files.
* @"disk_manyfiles"@: will store temporary data in a lot of small files. This option is less CPU-consuming than @"disk"@.

For data stored on disk, the temporary directory can be set using the @set("buffering.path", "/new/path")@ command.

The disk caching can also be used along with "ramfs":http://wiki.debian.org/ramfs or 
"tmpfs":http://en.wikipedia.org/wiki/TMPFS. In this case, 
files are also put in the RAM however, the temporary data is no longer managed by liquidsoap. This may
help to reduce the load generated by the garbage collector when dealing with important amount of 
allocated memory.
